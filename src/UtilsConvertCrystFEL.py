#!/usr/bin/env python
"""
Class :py:class:`UtilsConvertCrystFEL`
===========================================

Usage::
 
    from PSCalib.UtilsConvertCrystFEL import CrystFELGeometryParser

Created on 2020-09-03 by Mikhail Dubrovin
"""

import os
import sys
import numpy as np

import logging
logger = logging.getLogger(__name__)

#from PSCalib.GeometryAccess import GeometryAccess
#from PSCalib.SegGeometryStore import sgs
#from Detector.GlobalUtils import print_ndarr, info_ndarr
#from PSCalib.GlobalUtils import CFRAME_LAB, CFRAME_PSANA

#----------

def str_to_int_or_float(s):
    v = float(s)
    if v%1 == 0: v=int(v)
    return v

#----------

def sfields_to_xyz_vector(flds):
    """ converts ['+0.002583x', '-0.999997y', '+0.000000z'] to (0.002583, -0.999997, 0.000000)
    """
    v = (float(flds[0].strip('x')), float(flds[1].strip('y')))
    z = float(flds[2].strip('z')) if len(flds)==3 else 0
    v += (z,)
    return v

#----------

def header_crystfel():
    return\
    '\n; Geometry constants generated by genuine psana'\
    '\n'\
    '\nclen =  /LCLS/detector_1/EncoderValue'\
    '\nphoton_energy = /LCLS/photon_energy_eV'\
    '\nadu_per_eV = 0.1'\
    '\n'\
    '\ndata = /entry_1/data_1/data'\
    '\n'\
    '\ndim0 = %'\
    '\ndim1 = ss'\
    '\ndim2 = fs'\
    '\n'\
    '\n; mask = /entry_1/data_1/mask'\
    '\n; mask_good = 0x0000'\
    '\n; mask_bad = 0xffff'

#----------

"""
# per asic info:

p15a1/fs = -0.000000x +1.000000y
p15a1/ss = -1.000000x +0.000000y
p15a1/res = 10000.000             # resolution 1m / <pixel-size>
p15a1/corner_x = 2.500000
p15a1/corner_y = -628.500000
p15a1/coffset = 1.000000          # z-offset correction
p15a1/min_fs = 192
p15a1/max_fs = 383
p15a1/min_ss = 5280
p15a1/max_ss = 5455
p15a1/no_index = 0                # exclude panels from indexing

p15a1/coffset = -0.186288         # z[m] panel offset
"""

#----------

class CrystFELGeometryParser:
    """ :py:class:`CrystFELParser`
    """

    def __init__(self, args):
        self._class_name = self.__class__.__name__

        self.args = args
        #self.dic_args = vars(args)

        self.fname = args.fname
        self.ofname = args.ofname
        self.dettype = args.dettype
        self.valid = False

        self.load_crystfel_file()
        self.print_list_of_comments()
        self.print_list_of_ignored_records()
        self.print_dict_of_pars()


    def _parse_line_as_parameter(self, line):
        assert isinstance(line, str), 'line is not a str object'

        fields = line.split()
        nfields = len(fields)

        if fields[1] != '=':
            self.list_of_ignored_records.append(line)
            logger.warning('line does not contain "=", presumably not a parameter, ignored')
            return

        logger.debug('   fields: %s'% str(fields))

        keys = fields[0].split('/') # ex: p15a3/corner_y 

        nkeys = len(keys)
        if nkeys==1:
            if nfields>3:
                self.list_of_ignored_records.append(line)
                logger.warning('number of fields >3, ignored')
                return
            self.dict_of_pars[keys[0]] = fields[2]

        elif nkeys==2:
            k0, k1 = keys
            k0f = k0.lstrip('p').split('a')
            k0m = 'p.%02d'%int(k0f[0])
            if len(k0f)==2: k0m += '.%02d'%int(k0f[1])
            v = sfields_to_xyz_vector(fields[2:]) if k1 in ('fs','ss') else str_to_int_or_float(fields[2])

            if k0m in self.dict_of_pars.keys():
                self.dict_of_pars[k0m][k1] = v
            else:
                self.dict_of_pars[k0m] = {k1:v,}
           
        else:
            self.list_of_ignored_records.append(line)
            logger.warning('field[0]: %s contains unexpected number of keys, ignored' % fields[0])
            return

    def print_list_of_comments(self):
        msg = 'List of comments\n'\
            + '\n'.join(self.list_of_comments)
        logger.info(msg)


    def print_list_of_ignored_records(self):
        msg = 'List of odd records\n'\
            + '\n'.join(self.list_of_ignored_records)
        logger.info(msg)


    def print_dict_of_pars(self):
        keys = sorted(self.dict_of_pars.keys())
        msg = 'dict of parameters keys\n'
            #+ '\n'.join(keys)
        for k in keys:
            v = self.dict_of_pars[k]
            if isinstance(v,dict): 
                msg += '\n%s' % k
                for k2,v2 in v.items(): msg += '\n    %s: %s' % (k2,v2)
            else: msg += '\n%s: %s' % (k,v)
        logger.info(msg)


    def load_crystfel_file(self, fname=None):

        if fname is not None: self.fname = fname
        assert os.path.exists(self.fname), 'geometry file "%s" does not exist' % self.fname

        self.valid = False
            
        #self.reset_cash()
        self.list_of_comments = []
        self.list_of_ignored_records = []
        self.dict_of_pars = {}

        logger.debug('Load file: %s' % self.fname)

        f=open(self.fname,'r')
        for linef in f:
            line = linef.strip('\n')
            logger.debug(line)

            if not line.strip(): continue   # discard empty strings
            if line[0] == ';':              # accumulate list of comments
                self.list_of_comments.append(line)
                continue

            self._parse_line_as_parameter(line)
    
        f.close()
    
        #self._set_relations()
        self.valid = True
 
#----------

def convert_detector_any(args):

    CrystFELGeometryParser(args)
    sys.exit('TEST EXIT')

    dettype, fname, ofname = args.dettype, args.fname, args.ofname

    if False: pass
#    if   'epix10ka' in dettype.lower(): geometry_to_crystfel(sgs.Create(segname='EPIX10KA:V1',pbits=0), (1,4,16), fname, ofname)
#    elif 'jungfrau' in dettype.lower(): geometry_to_crystfel(sgs.Create(segname='JUNGFRAU:V1',pbits=0), (1,2,8), fname, ofname)
#    elif 'cspad'    in dettype.lower(): geometry_to_crystfel(sgs.Create(segname='SENS2X1:V1', pbits=0), (1,8,32), fname, ofname)
#    elif 'pnccd'    in dettype.lower(): geometry_to_crystfel(sgs.Create(segname='PNCCD:V1',   pbits=0), (4,), fname, ofname)
    else: logger.warning('NON_IMPLEMENTED DETECTOR TYPE: %s' % dettype)

#----------

if __name__ == "__main__":

    def test_epix10ka_any(fname, ofname='geo_epix10ka_crystfel.txt'):
        pass
    #    geometry_to_crystfel(sgs.Create(segname='EPIX10KA:V1',pbits=0), (1,4,16), fname, ofname)

    #def test_jungfrau_any(fname, ofname='geo_jungfrau_crystfel.txt'):
    #    geometry_to_crystfel(sgs.Create(segname='JUNGFRAU:V1',pbits=0), (1,2,8), fname, ofname)

    #def test_cspad_any(fname, ofname='geo_cspad_crystfel.txt'):
    #    geometry_to_crystfel(sgs.Create(segname='SENS2X1:V1',pbits=0), (1,8,32), fname, ofname)

    #def test_pnccd(fname, ofname='geo_pnccd_crystfel.txt'):
    #    geometry_to_crystfel(sgs.Create(segname='PNCCD:V1',pbits=0), (4,), fname, ofname)

#----------

if __name__ == "__main__":

    #import pyimgalgos.GlobalGraphics as gg
    scrname = sys.argv[0].rsplit('/')[-1]

    fname_epix10ka2m = '/reg/g/psdm/detector/data2_test/geometry/crystfel/geo-epix10ka2m.1-v1-mfxc00318-0013-z0-mirror.geom'
    fname_pnccd      = '/reg/g/psdm/detector/data2_test/geometry/crystfel/geo-amox26916-pnccd-front-108-psana-crystfel.geom'
    fname_pnccd      = '/reg/g/psdm/detector/data2_test/geometry/crystfel/geo-amox26916-pnccd-front-108-psgeom-crystfel.geom'
    d_dettype = 'epix10ka'
    #d_fname   = fname_epix10ka2m
    d_fname   = fname_pnccd
    d_ofname  = 'geo-psana.txt'
    d_loglev  ='INFO'

    usage = '\nE.g.: %s' % scrname\
      + '\n  or: %s -t <test-number: 1,2,3,4,5,...>' % (scrname)\
      + '\n  or: %s -d epix10ka -f %s -o geo_crystfel.txt -l DEBUG' % (scrname, d_fname)

    import argparse

    parser = argparse.ArgumentParser(usage=usage)
    parser.add_argument('-t', '--tname',   default='0',       type=str, help='test number: 1/2/3/4/5 = epix10ka/jungfrau/cspad/epix10ka/pnccd-default')
    parser.add_argument('-d', '--dettype', default=d_dettype, type=str, help='detector type, i.e. epix10ka, jungfrau, cspad, pnccd, def=%s' % d_dettype)
    parser.add_argument('-f', '--fname',   default=d_fname,   type=str, help='input geometry file name, def=%s' % d_fname)
    parser.add_argument('-o', '--ofname',  default=d_ofname,  type=str, help='output file name, def=%s' % d_ofname)
    #parser.add_argument('-l', '--loglev',  default=d_loglev,  type=str, help='logging level name, one of %s, def=%s' % (STR_LEVEL_NAMES, d_loglev))

    args = parser.parse_args()
    print('Arguments:') #%s\n' % str(args))
    for k,v in vars(args).items(): print('  %12s : %s' % (k, str(v)))

    logging.basicConfig(format='[%(levelname).1s] L%(lineno)04d : %(message)s', datefmt='%Y-%m-%dT%H:%M:%S', level=logging.DEBUG)

    tname = args.tname

    if   tname=='0': convert_detector_any(args)
    #elif tname=='1': test_epix10ka_any(fname_epix10ka2m)
    #elif tname=='2': test_jungfrau_any(fname_jungfrau_8)
    #elif tname=='3': test_cspad_any(fname_cspad_cxi)
    #elif tname=='4': test_epix10ka_any(fname_epix10ka2m_def)
    elif tname=='5': test_pnccd(fname_pnccd)
    else: logger.warning('NON-IMPLEMENTED TEST: %s' % tname)

    sys.exit('END OF %s' % scrname)

#----------
